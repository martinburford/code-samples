import { Meta, Preview, Props, Story } from '@storybook/addon-docs/blocks';
import { useState } from 'react';

<!-- Components -->

import Checkbox from 'components/ui/atoms/checkbox';
import CodeBlock from '.storybook/components/code-block';
import Grid from 'components/ui/global/grid';
import InformationPanel from 'components/ui/demo/information-panel';
import Modal from 'components/ui/atoms/modal';
import StoryHeading from '.storybook/components/story-heading';

<!-- Data -->

import Data from './modal.json';

<!-- Styles -->

import '.storybook/components/modal/modal.scss';

<Meta
  parameters={{
    controls: {
      sort: 'alpha',
    },
  }}
  title="Atoms/Modal"
/>

# Modal

Modals can be included within a page in one of two important modes:

### Embedded

All examples in this Story file are shown as embedded Modals, as it's slightly more visual to demonstrate these via Storybook. Embedded Modals are launched within a child DOM element, and restrcited to the outer bounds of that element. In the case of this Story file, the restrictive `parent` elements are reasonably small in size. However, there is no restriction on what parent DOM elements a Modal can be embedded within.

### Full-screen

If wishing to attach a Modal to the body of a page, do not define a `parent` prop for that Modal.

<InformationPanel leadIn="Unique component id">modal</InformationPanel>

## Component props

<Props of={Modal} />

<!-- Embedded: bottom -->

<Preview withSource="none">
  <Story name="Embedded: bottom">
    {(args, { globals: { locale } }) => {
      const [visible, updateState] = useState(false);
      return (
        <>
          <StoryHeading
            heading="Embedded: bottom"
            summary={
              <>
                To embed the Modal within another DOM element, provide a CSS selector to the desired element via the{' '}
                <code>parent</code> prop. Specify that the Modal appears from the bottom of the element by providing a
                value of <code>bottom</code> to the <code>position</code> prop.
              </>
            }
          />
          <Checkbox
            checked={visible}
            label="Toggle modal visibility"
            name="modal-position-bottom-onchange"
            onChange={event => {
              updateState(!visible);
            }}
            value="#"
          />
          <Grid.Row withBorder={true} withColourColumns={true}>
            <Grid.Col span={12}>
              <div data-modal-id="modal-bottom">Element that Modal will overlap</div>
            </Grid.Col>
          </Grid.Row>
          <Modal
            dataAttributes={{ 'data-component-spacing': '0' }}
            footer={Data[locale].footerContent}
            header={Data[locale].heading}
            lockBodyScroll={false}
            onClose={() => updateState(false)}
            parent="[data-modal-id='modal-bottom']"
            position="bottom"
            visible={visible}
          >
            {Data[locale].mainContent}
          </Modal>
          <br />
          The DOM element that the modal will be appended to, to ensure relative positioning is correctly used:
          <CodeBlock language="jsx">{`<div data-modal-id="modal-bottom">
  ...
</div>
`}</CodeBlock>
          <br />
          The modal code:
          <CodeBlock language="jsx">{`<Modal
  footer="${Data[locale].footerContent}"
  header="${Data[locale].heading}"
  onClose={() => {}}
  parent="[data-modal-id='modal-bottom']"
  position="bottom"
  visible={false}
>
 ${Data[locale].mainContent}
</Modal>`}</CodeBlock>
        </>
      );
    }}
  </Story>
</Preview>

<!-- Embedded: centre -->

<Preview withSource="none">
  <Story name="Embedded: centre">
    {(args, { globals: { locale } }) => {
      const [visible, updateState] = useState(false);
      return (
        <>
          <StoryHeading
            heading="Embedded: centre"
            summary={
              <>
                To embed the Modal within another DOM element, provide a CSS selector to the desired element via the{' '}
                <code>parent</code> prop. Specify that the Modal appears in the centre of the element by providing a
                value of <code>centre</code> to the <code>position</code> prop.
              </>
            }
          />
          <Checkbox
            checked={visible}
            label="Toggle modal visibility"
            name="modal-position-center-onchange"
            onChange={event => {
              updateState(!visible);
            }}
            value="#"
          />
          <Grid.Row withBorder={true} withColourColumns={true}>
            <Grid.Col span={12}>
              <div data-modal-id="modal-center">Element that Modal will overlap</div>
            </Grid.Col>
          </Grid.Row>
          <Modal
            dataAttributes={{ 'data-component-spacing': '0' }}
            footer={Data[locale].footerContent}
            header={Data[locale].heading}
            lockBodyScroll={false}
            onClose={() => updateState(false)}
            parent="[data-modal-id='modal-center']"
            position="centre"
            visible={visible}
          >
            {Data[locale].mainContent}
          </Modal>
          <br />
          The DOM element that the modal will be appended to, to ensure relative positioning is correctly used:
          <CodeBlock language="jsx">{`<div data-modal-id="modal-center">
  ...
</div>
`}</CodeBlock>
          <br />
          The modal code:
          <CodeBlock language="jsx">{`<Modal
  footer="${Data[locale].footerContent}"
  header="${Data[locale].heading}"
  onClose={() => {}}
  parent="[data-modal-id='modal-center']"
  position="center"
  visible={false}
>
 ${Data[locale].mainContent}
</Modal>`}</CodeBlock>
        </>
      );
    }}
  </Story>
</Preview>

<!-- Embedded: left -->

<Preview withSource="none">
  <Story name="Embedded: left">
    {(args, { globals: { locale } }) => {
      const [visible, updateState] = useState(false);
      return (
        <>
          <StoryHeading
            heading="Embedded: left"
            summary={
              <>
                To embed the Modal within another DOM element, provide a CSS selector to the desired element via the{' '}
                <code>parent</code> prop. Specify that the Modal appears from the left-side of the element by providing
                a value of <code>left</code> to the <code>position</code> prop.
              </>
            }
          />
          <Checkbox
            checked={visible}
            label="Toggle modal visibility"
            name="modal-embedded-left-onchange"
            onChange={event => {
              updateState(!visible);
            }}
            value="#"
          />
          <Grid.Row withBorder={true} withColourColumns={true}>
            <Grid.Col span={12}>
              <div data-modal-id="modal-left">Element that Modal will overlap</div>
            </Grid.Col>
          </Grid.Row>
          <Modal
            dataAttributes={{ 'data-component-spacing': '0' }}
            footer={Data[locale].footerContent}
            header={Data[locale].heading}
            lockBodyScroll={false}
            onClose={() => updateState(false)}
            parent="[data-modal-id='modal-left']"
            position="left"
            visible={visible}
          >
            {Data[locale].mainContent}
          </Modal>
          <br />
          The DOM element that the modal will be appended to, to ensure relative positioning is correctly used:
          <CodeBlock language="jsx">{`<div data-modal-id="modal-left">
  ...
</div>
`}</CodeBlock>
          <br />
          The modal code:
          <CodeBlock language="jsx">{`<Modal
  footer="${Data[locale].footerContent}"
  header="${Data[locale].heading}"
  onClose={() => {}}
  parent="[data-modal-id='modal-left']"
  position="left"
  visible={false}
>
 ${Data[locale].mainContent}
</Modal>`}</CodeBlock>
        </>
      );
    }}
  </Story>
</Preview>

<!-- Embedded: right -->

<Preview withSource="none">
  <Story name="Embedded: right">
    {(args, { globals: { locale } }) => {
      const [visible, updateState] = useState(false);
      return (
        <>
          <StoryHeading
            heading="Embedded: right"
            summary={
              <>
                To embed the Modal within another DOM element, provide a CSS selector to the desired element via the{' '}
                <code>parent</code> prop. Specify that the Modal appears from the left-side of the element by providing
                a value of <code>right</code> to the <code>position</code> prop.
              </>
            }
          />
          <Checkbox
            checked={visible}
            label="Toggle modal visibility"
            name="modal-embedded-right-onchange"
            onChange={event => {
              updateState(!visible);
            }}
            value="#"
          />
          <Grid.Row withBorder={true} withColourColumns={true}>
            <Grid.Col span={12}>
              <div data-modal-id="modal-right">Element that Modal will overlap</div>
            </Grid.Col>
          </Grid.Row>
          <Modal
            dataAttributes={{ 'data-component-spacing': '0' }}
            footer={Data[locale].footerContent}
            header={Data[locale].heading}
            lockBodyScroll={false}
            onClose={() => updateState(!visible)}
            parent="[data-modal-id='modal-right']"
            position="right"
            visible={visible}
          >
            {Data[locale].mainContent}
          </Modal>
          <br />
          The DOM element that the modal will be appended to, to ensure relative positioning is correctly used:
          <CodeBlock language="jsx">{`<div data-modal-id="modal-right">
  ...
</div>
`}</CodeBlock>
          <br />
          The modal code:
          <CodeBlock language="jsx">{`<Modal
  footer="${Data[locale].footerContent}"
  header="${Data[locale].heading}"
  onClose={() => {}}
  parent="[data-modal-id='modal-right']"
  position="right"
  visible={false}
>
 ${Data[locale].mainContent}
</Modal>`}</CodeBlock>
        </>
      );
    }}
  </Story>
</Preview>

<!-- Embedded: long content -->

<Preview withSource="none">
  <Story name="Embedded: long content">
    {(args, { globals: { locale } }) => {
      const [visible, updateState] = useState(false);
      return (
        <>
          <StoryHeading
            heading="Embedded: long content"
            summary={
              <>
                If the main content of the Modal happens to be longer in length, the Modal has been written to keep both
                the header and footer elements fixed in their respective top and bottom positions, with the central
                content of the Modal automatically adding vertical scrolling.
              </>
            }
          />
          <Checkbox
            checked={visible}
            label="Toggle modal visibility"
            name="modal-long-content"
            onChange={event => {
              updateState(!visible);
            }}
            value="#"
          />
          <Grid.Row withBorder={true} withColourColumns={true}>
            <Grid.Col span={12}>
              <div data-modal-id="modal-long-content">Element that Modal will overlap</div>
            </Grid.Col>
          </Grid.Row>
          <Modal
            dataAttributes={{ 'data-component-spacing': '0' }}
            footer={Data[locale].footerContent}
            header={Data[locale].heading}
            lockBodyScroll={false}
            onClose={() => updateState(!visible)}
            parent="[data-modal-id='modal-long-content']"
            position="left"
            visible={visible}
          >
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}{' '}
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}{' '}
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}{' '}
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}{' '}
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}{' '}
            {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent} {Data[locale].mainContent}
          </Modal>
          <br />
          The DOM element that the modal will be appended to, to ensure relative positioning is correctly used:
          <CodeBlock language="jsx">{`<div data-modal-id="modal-long-content">
  ...
</div>
`}</CodeBlock>
          <br />
          The modal code:
          <CodeBlock language="jsx">{`<Modal
  footer="${Data[locale].footerContent}"
  header="${Data[locale].heading}"
  onClose={() => {}}
  parent="[data-modal-id='modal-long-content']"
  position="left"
  visible={false}
>
  ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent}
  ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent}
  ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent} ${Data[locale].mainContent}
</Modal>`}</CodeBlock>
        </>
      );
    }}
  </Story>
</Preview>
